install.packages("plotrix")
TheData<-c(rep("0-0.25",30),rep("0.25-0.75",30),rep("0.75-1.25",22),rep("1.25-Inf",18))
Numbers=table(TheData); Numbers#top line of table, middle of p. 65 of Chihara-Hesterberg
pBin1 <- integrate(dexp, 0, 0.25)$value; 100*pBin1
pBin2 <- integrate(dexp, 0.25, 0.75)$value; 100*pBin2
pBin3 <- integrate(dexp, 0.75, 1.25)$value; 100*pBin3
pBin4 <- integrate(dexp, 1.25, Inf)$value; 100*pBin4
Expected <- 100*c(pBin1,pBin2,pBin3,pBin4); Expected
100*c(pexp(0.25),pexp(0.75)-pexp(0.25),pexp(1.25)-pexp(0.75),1-pexp(1.25)); Expected
a <- 1.5; b = 2.8   #Lower and upper bounds of integration
f <- function(x) x+sin(10*x)/2   #the function to integrate
plot(f, a, b)
Psub <- runif(8, a, b);Psub #generate 8 subdivision points in (a,b)
P <- sort(c(a,b,Psub));P     #add endpoints and put the division points in order
axis(1, at = P, labels = FALSE, col = "red")
abline(v=P, col = "red")
m <- optimize(f, c(P[2], P[3])); m$minimum; abline(h=m$objective, col = "green");
abline(v=m$minimum, col = "green")
M <- optimize(f, c(P[2], P[3]),maximum = TRUE); M$objective;
abline(h=M$objective, col = "blue");abline(v=M$maximum, col = "blue")
m <- optimize(f, c(P[2], P[3])); m$minimum; abline(h=m$objective, col = "green");
abline(v=m$minimum, col = "green")
M <- optimize(f, c(P[2], P[3]),maximum = TRUE); M$objective;
abline(h=M$objective, col = "blue");abline(v=M$maximum, col = "blue")
#Now we can calculate the lower Darboux sum for a given partition
DarbouxL <- function(f, Part) {
Dsum <- 0
for (i in 1:(length(Part)-1)) {
Dsum <- Dsum + (Part[i+1]-Part[i])*optimize(f, c(Part[i], Part[i+1]) )$objective
}
return(Dsum)
}
integrate(f,a,b)    #the correct value
DarbouxL(f,P);       #too small
Qsub <- runif(5, a, b) #generate 5 subdivision points in (a,b)
Q <- sort(c(a,b,Qsub))    #put the division points in order
axis(1, at = Q, labels = FALSE, col = "magenta")
abline(v=Q, col = "magenta")
DarbouxL(f,Q)       #also too small but not necessarily less than DarbouxL(f,P)
PQ <- sort(c(a,b,Psub,Qsub))     #union of partitions P and Q;
DarbouxL(f,PQ)    #guaranteed larger than either for P or for Q
DarbouxU <- function(f, Part) {
Dsum <- 0
for (i in 1:(length(Part)-1)) {
Dsum <- Dsum + (Part[i+1]-Part[i])*optimize(f, c(Part[i], Part[i+1]),maximum = TRUE )$objective
}
return(Dsum)
integrate(f,a,b)    #the correct value
integrate(f,a,b)    #the correct value
DarbouxL(f,P)     #slightly too small
DarbouxU(f,P)
#Math 23c Script 4M-Integration.R
#Last modified: February 11, 2018
#Topic 1: Darboux integrals -- creating a partition
a <- 1.5; b = 2.8   #Lower and upper bounds of integration
f <- function(x) x+sin(10*x)/2   #the function to integrate
plot(f, a, b)
Psub <- runif(8, a, b);Psub #generate 8 subdivision points in (a,b)
P <- sort(c(a,b,Psub));P     #add endpoints and put the division points in order
axis(1, at = P, labels = FALSE, col = "red")
abline(v=P, col = "red")
#The R function "optimize" finds the maximum or minimum of a function on a interval.
#It returns a 2-component vector with the min or max value ("objective")
#and the x where it is achieved
m <- optimize(f, c(P[2], P[3])); m$minimum; abline(h=m$objective, col = "green");
abline(v=m$minimum, col = "green")
M <- optimize(f, c(P[2], P[3]),maximum = TRUE); M$objective;
abline(h=M$objective, col = "blue");abline(v=M$maximum, col = "blue")
#Now we can calculate the lower Darboux sum for a given partition
DarbouxL <- function(f, Part) {
Dsum <- 0
for (i in 1:(length(Part)-1)) {
Dsum <- Dsum + (Part[i+1]-Part[i])*optimize(f, c(Part[i], Part[i+1]) )$objective
}
return(Dsum)
}
integrate(f,a,b)    #the correct value
DarbouxL(f,P);       #too small
Qsub <- runif(5, a, b) #generate 5 subdivision points in (a,b)
Q <- sort(c(a,b,Qsub))    #put the division points in order
axis(1, at = Q, labels = FALSE, col = "magenta")
abline(v=Q, col = "magenta")
DarbouxL(f,Q)       #also too small but not necessarily less than DarbouxL(f,P)
PQ <- sort(c(a,b,Psub,Qsub))     #union of partitions P and Q;
DarbouxL(f,PQ)    #guaranteed larger than either for P or for Q
#we can calculate the upper Darboux sum similarly
DarbouxU <- function(f, Part) {
Dsum <- 0
for (i in 1:(length(Part)-1)) {
Dsum <- Dsum + (Part[i+1]-Part[i])*optimize(f, c(Part[i], Part[i+1]),maximum = TRUE )$objective
}
return(Dsum)
}
DarbouxU(f,P); DarbouxU(f,Q)       #should both be too large
DarbouxU(f,PQ)    #guaranteed smaller than either for P or for Q
#If we use a large number of subdivisions the Darboux sums get close to the integral.
Psub <- runif(800, a, b) #generate 800 subdivision points in (a,b)
P <- sort(c(a,b,Psub))     #add endpoints and put the division points in order
integrate(f,a,b)    #the correct value
DarbouxL(f,P)     #slightly too small
DarbouxU(f,P)     #slightly too large
#This is not an efficient way to do numerical integration!
#Topic 2: Riemann integrals, done with n equal subdivisions: example for n = 2
seq( from = a, to = b, length.out = 3)
#Left Riemann sum
RiemannL <- function(f, a, b, n){
Part <- seq( from = a, to = b, length.out = n+1)
Rsum <- 0
for (i in 1:(length(Part)-1)) {
Rsum <- Rsum + (Part[i+1]-Part[i])*f(Part[i])
}
return(Rsum)
}
RiemannR <- function(f, a, b, n){
Part <- seq( from = a, to = b, length.out = n+1)
Rsum <- 0
for (i in 1:(length(Part)-1)) {
Rsum <- Rsum + (Part[i+1]-Part[i])*f(Part[i+1])
}
return(Rsum)
}
RiemannTrap <- function(f, a, b, n){
Part <- seq( from = a, to = b, length.out = n+1)
Rsum <- 0
for (i in 1:(length(Part)-1)) {
Rsum <- Rsum + (Part[i+1]-Part[i])*(f(Part[i])+f(Part[i+1]))/2
}
return(Rsum)
}
RiemannMid <- function(f, a, b, n){
Part <- seq( from = a, to = b, length.out = n+1)
Rsum <- 0
for (i in 1:(length(Part)-1)) {
Rsum <- Rsum + (Part[i+1]-Part[i])*f(Part[i]+(b-a)/(2*n))
}
return(Rsum)
}
RiemannSimpson <- function(f, a, b, n){
Part <- seq( from = a, to = b, length.out = n+1)
Rsum <- 0
for (i in 1:(length(Part)-1)) {
Rsum <- Rsum + (Part[i+1]-Part[i])*(4*f(Part[i]+(b-a)/(2*n))+f(Part[i])+f(Part[i+1]))/6
}
return(Rsum)
}
integrate(f,a,b)    #the correct value
RiemannL(f,a,b,10)
RiemannR(f,a,b,10)
RiemannTrap(f,a,b,10); (RiemannL(f,a,b,10)+RiemannR(f,a,b,10))/2
RiemannMid(f,a,b,10)
RiemannSimpson(f,a,b,10); integrate(f,a,b)     #really close
#Topic 3: The gamma function
curve(gamma(x), from = 0.15, to = 4.2 )
abline(v=c(seq(from = 0.5, to = 4.0, by = 0.5)),col = "red")
#For integers, gamma(n) = factorial(n-1)
abline(h=factorial(c(0,1,2,3)),col = "blue")
#For half integers, gamma(n+1/2) is a rational multiple of sqrt(pi)
abline(h=sqrt(pi)*c(1,0.5,0.5*1.5,0.5*1.5*2.5),col = "green")
#R does a good job with improper integrals
my.gamma = function(r){
f <- function(x) x^(r-1)*exp(-x)
integrate(f, 0, Inf)
}
my.gamma(3)
my.gamma(1/2); sqrt(pi)
#R does not do so well with the Fresnel improper integral
f <- function(x) sin(x^2)
integrate(f, 0, Inf)
for (i in (1:100)*pi) {
print (integrate(f, 0, sqrt(i)))
}
#This is a very slowly convergent sequence!
#Topic 4: Checking normalization and expectation for some density functions
#Exponential
curve(dexp(x,2), 0, 4)
f <- function(x) dexp(x,2)
integrate(f, 0, Inf)
f <- function(x) x*dexp(x,2)
integrate(f, 0, Inf)
#Standard normal
curve(dnorm(x), -4, 4)
f <- function(x) dnorm(x)
integrate(f, -Inf, Inf)
f <- function(x) x*dnorm(x)
integrate(f, -Inf, Inf)
#Gamma with r = 3, lambda = 2
curve(dgamma(x,3,rate = 2), 0, 4)
f <- function(x) dgamma(x,3,rate = 2)
integrate(f, 0, Inf)
#Theory says the expectation is r/lambda.
f <- function(x) x*dgamma(x,3,rate = 2)
integrate(f, 0, Inf)
#Chi square with 4 degrees of freedom
curve(dchisq(x, df=4), 0, 12)
curve(dgamma(x,2, rate = 1/2),col = "red", add = TRUE)    #the same function!
f <- function(x) dchisq(x, df=4)
integrate(f, 0, Inf)
f <- function(x) x*dchisq(x, df=4)
integrate(f, 0, Inf)
#Chi square with 1 degree of freedom
curve(dchisq(x, df=1), 0, 6)    #an unbounded function
curve(dgamma(x,1/2, rate = 1/2),col = "red", add = TRUE)    #the same function!
f <- function(x) dchisq(x, df=1)
integrate(f, 0, Inf)     #this integral is improper at both endpoints!
#For the gamma version, the expectation formula is r/lambda.
f <- function(x) x*dchisq(x, df=1)
integrate(f, 0, Inf)
curve(dnorm(x,0,1), from =-3, to = -3, ylab = """)
curve(dnorm(x,0,1), from =-3, to = 3, ylab = """)
curve(dnorm(x,0,1), from =-3, to = 3, ylab = """)
curve(dnorm(x,0,1), from =-3, to = 3, ylab = """)
curve(dnorm(x,0,1), from =-3, to = 3, ylab = """)
curve(dnorm(x,0,1), from =-3, to = 3, ylab = "")
curve(dnorm(x,0,1), from =-3, to = 3, ylab = "")
curve(pnorm(x,0,1), from =-3, to = 3, ylab = "")
curve(dbeta(x,0,1), from =-3, to = 3, ylab = "")
curve(pbeta(x,0,1), from =-3, to = 3, ylab = "")
curve(dt(x,0,1), from =-3, to = 3, ylab = "")
curve(dt(x,0,1), from =-3, to = 3, ylab = "")
curve(dt(x,0,1), from =-3, to = 3, ylab = "")
curve(pnorm(x,0,1), from =-3, to = 3, ylab = "")
install.packages(c("colorRamps", "numDeriv"))
nstall.packages("numDeriv")
install.packages("numDeriv")
#Topic 1 - Plotting a vector field and its derivative in R^2
#At selected points, we represent the function value by an "anchored vector."
F1 <- function(x,y) -y/(x^2 + y^2)       #the x-component of the vector field
F2 <- function(x,y) x/(x^2 + y^2)     #the y-component of the vector field
#Define a function whose domain and codomain are both R^2.
FVec <- function(v) {
return(-v[2]/(v[1]^2 + v[2]^2),v[1]/(v[1]^2 + v[2]^2))
}
#Plot this in the square where x and y range from 0.5 to 2.6.
xSeq <- ySeq <- seq(-3,3, 0.2)
par(mar = c(2,2,1,1))      #make margins as small as possible
plot(NULL, xlim = c(-3,3), ylim = c(-2,2)) #leave room for the arrows
scale <- 0.02 #controls the length of the arrows
for (x in xSeq) {
for (y in ySeq) {
arrows(x,y,x+scale*F1(x,y),y+scale*F2(x,y), length = 0.05)
}
}
setwd("~/Desktop/Math 23C/23c-rproject")
install.packages("remotes")
install.packages("modules")
install.packages("lintr")
install.packages("styler")
install.packages("spelling")
install.packages("tidyverse")
install.packages("ggrepel")
install.packages("remotes")
remotes::install_github("lorenzwalthert/precommit")
setwd("~/Desktop/Math 23C/23c-rproject")
data <- read.csv("data/ResultsByParty.csv")
head(data)
library(dplyr)
install.packages("dplyr")
library(dplyr)
library(dplyr)
uk_parties <- table %>% filter(table$ISO == "GBR")
setwd("~/Desktop/Math 23C/23c-rproject")
install.packages("ggpubr")
library(dplyr)
head(data)
data$Ideology
gender <- data$Gender; head(gender)
data$Gender
data[181]
data[181,]
data[182,]
load("~/Desktop/Math 23C/23c-rproject/data/Global Party Survey by Party Stata V2_1_Apr_2020.RData")
head(data)
data <- read.csv("data/ResultsByExpert.csv")
setwd("~/Desktop/Math 23C/23c-rproject")
data <- read.csv("data/ResultsByExpert.csv")
data <- read.csv(file.choose())
head(data)
data$R_Gender
data$R_ideology
data <- read.csv("ResponsesByExpert.csv")
data <- read.csv("data/ResponsesByExpert.csv")
head(data)
idx.male <- which(gender == 1)
idx.male
male.avg <- mean(na.omit(ideologies[idx.male])); male.avg
ideologies <- data$R_ideology
male.avg <- mean(na.omit(ideologies[idx.male])); male.avg
idx.female <- which(gender == 0); idx.female
female.avg <- mean(na.omit(ideologies[idx.female])); female.avg
obs <- male.avg - female.avg;obs
obs <- male.avg - female.avg;obs
#num of trials
N <- 10000
#vector to store results
Diffs <- numeric(N)
for (i in 1:N) {
Labels <- sample(gender)
idx.male.loop <- which(Labels == 1)
male.avg.loop <- mean(na.omit(ideologies[idx.male.loop]))
idx.fmale.loop <- which(Labels == 0)
female.avg.loop <- mean(na.omit(ideologies[idx.fmale.loop]))
Diffs[i] <- male.avg.loop - female.avg.loop
}
mean(Diffs)
hist(Diffs, breaks = "Fd")
abline(v= obs, col = "blue")
pv.1t <- (sum(Diffs >= obs)+1)/(N+1); pv.1t #0.440456
pv.2t <- 2*pv.1t;pv.2t
obs <- male.avg - female.avg;obs
mean(Diffs)
data <- read.csv("data/ResponsesByExpert.csv")
gender <- data$R_Gender
ideologies <- data$R_ideology
data$R_ideology
data <- read.csv("data/ResponsesByExpert.csv")
setwd("~/Desktop/Math 23C/23c-rproject")
data <- read.csv("data/ResponsesByExpert.csv")
data <- read.csv("data/ResponsesByExpert.csv")
data <- read.csv("data/ResponsesByExpert.csv")
setwd("../")
data <- read.csv("data/ResponsesByExpert.csv")
rm(list = ls())
setwd("../")
data <- read.csv("data/ResponsesByExpert.csv")
setwd("../data")
setwd("data")
setwd("../data")
data <- read.csv("data/ResponsesByExpert.csv")
data <- read.csv("ResponsesByExpert.csv")
data <- read.csv(file.choose())
data <- read.csv(file.choose())
data <- read.csv(file.choose())
setwd("../data")
setwd("../")
data <- read.csv("/data/ResponsesByExpert.csv")
setwd("../")
rm(list = ls())
setwd("../")
data <- read.csv("/data/ResponsesByExpert.csv")
data <- read.csv2("/data/ResponsesByExpert.csv")
getwd()
setwd("~/Desktop/Math 23C/23c-rproject")
getwd()
setwd("../")
getwd()
data <- read.csv("../data/ResponsesByExpert.csv")
rm(list = ls())
setwd("../")
data <- read.csv("../data/ResponsesByExpert.csv")
install.packages("mixtools")
install.packages("mixtools")
install.packages(mixtools)
install.packages(mixtools)
library(mixtools)
load("./data/Global Party Survey by Party Stata V2_1_Apr_2020.RData")
